#!/usr/bin/env python3
import sys
import os
import json
import time
import uuid
from datetime import datetime

# Configuration
BASE_DIR = "/app"
MAILBOX_DIR = os.path.join(BASE_DIR, "mailbox")
INBOX_DIR = os.path.join(MAILBOX_DIR, "inbox")
OUTBOX_DIR = os.path.join(MAILBOX_DIR, "outbox")
TASKS_DIR = os.path.join(BASE_DIR, "tasks")
TASKS_FILE = os.path.join(TASKS_DIR, "running.json")

def load_tasks():
    if os.path.exists(TASKS_FILE):
        try:
            with open(TASKS_FILE, "r") as f:
                return json.load(f)
        except:
            return {}
    return {}

def print_dashboard():
    print("""
\033[1;36m
     ▌ ▄▖▄▖
▛▛▌█▌▙▘▌▌▚ 
▌▌▌▙▖▛▖▙▌▄▌
                                        
mekOS v1.0 - Personal Assistant
\033[0m""")
    
    # Check Outbox (Unread Updates)
    # Ideally "Unread" means not yet acknowledged.
    # For MVP, we count existing files in Outbox as 'unread' since the user hasn't cleared them (or we clear them on read).
    
    unread_files = [f for f in os.listdir(OUTBOX_DIR) if f.endswith(".json")]
    print(f"Updates: \033[1;33m{len(unread_files)} unread messages\033[0m")
    
    # List Tasks
    data = load_tasks()
    tasks = data.get("tasks", [])
    if tasks:
        print("\nActive Tasks:")
        for t in tasks:
            print(f"  - [{t['status']}] {t['name']}")
    else:
        print("\nNo active sub-agents running.")
        
    print("\n------------------------------------------------")

def send_message(text):
    msg_id = str(uuid.uuid4())
    message = {
        "id": msg_id,
        "source": "user",
        "text": text,
        "timestamp": str(datetime.now())
    }
    
    path = os.path.join(INBOX_DIR, f"{msg_id}.json")
    with open(path, "w") as f:
        json.dump(message, f, indent=2)
    
    return msg_id

def wait_for_reply(correlation_id):
    # Poll outbox for a message with this correlation_id
    print("\033[1;30mWaiting for response...\033[0m")
    try:
        while True:
            for f in os.listdir(OUTBOX_DIR):
                if not f.endswith(".json"): continue
                path = os.path.join(OUTBOX_DIR, f)
                try:
                    with open(path, "r") as fp:
                        data = json.load(fp)
                    if data.get("correlation_id") == correlation_id:
                        # Found it!
                        # Clear it (mark read)
                        text = data.get("text", "")
                        os.remove(path)
                        return text
                except:
                    continue
            time.sleep(0.5)
    except KeyboardInterrupt:
        return None

def run_repl():
    print("Connecting to Daemon... (Type 'exit' to quit)")
    
    while True:
        try:
            user_input = input("\033[1;32mmekOS>\033[0m ")
            if user_input.strip().lower() in ['exit', 'quit']:
                break
            if not user_input.strip():
                continue
            
            # Send
            msg_id = send_message(user_input)
            
            # Wait
            reply = wait_for_reply(msg_id)
            if reply:
                print(f"\n{reply}\n")
            else:
                print("\n(Action cancelled)\n")
                
        except KeyboardInterrupt:
            print("\nExiting...")
            break
        except Exception as e:
            print(f"\033[1;31mError: {e}\033[0m")

def main():
    print_dashboard()
    run_repl()

if __name__ == "__main__":
    main()
